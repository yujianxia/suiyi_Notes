# 第13天 说说你对javascript的作用域的理解

## 总结

### 全局作用域

这个没啥说的，就是在顶层环境中申明的变量都是全局作用域，他们的属性其实都在window对象下面。

### 函数作用域

在函数内部定义的变量都是函数作用域，只能在函数中访问到，当然也可以通过闭包来访问。除此之外，在其他地方是没法访问函数内部的变量的。

### 局部作用域

`es6`中新增的特性，弥补了以前只能使用匿名及时运行函数来创建局部变量的缺陷。使用很简单，直接用`let`来申明变量就行。也可以使用`const`来申明变量，表明这是常数。

### 作用域链

要说清这个，需要首先明白`javascript`的代码运行过程。假设现在有个函数`funcA`，在该函数内部申明了一个局部变量a，在函数内部又定义了一个函数`funcB`，在函数B中申明了变量b。如下：

```js
function funcA () {
    let a;
    function funcB () {
        let b;
    }
}
```

当进入`funcA`时，这时候会把变量`a`压入当前的作用域`A`中，并且将作用域`A`入栈，当进入`funcB`时，则会把变量`b`压入当前的作用域`B`中，并且将作用域`B`入栈，那么这时候栈中就有了作用域`A`和作用域`B`，当在`funcB`中查找某个变量时，会先从当前的作用域`B`中查找，如果没有的话，那么就根据栈中的作用域依次往上查找，这就是作用域链。

## 补充

1. js是使用的词法作用域，所以当代码被加载时作用域已经被限定。

2. 作用域只会引用当前作用域用到的 上层作用域的变量 其他没用到的将会随该函数一起推出调用栈

## 另一种说法

### 作用域

* 作用域是一组规则，决定了一个变量（标识符）在哪里和如何被查找。

* 查找变量用于赋值，变量是一个 `LHS`（左手边）引用；查找变量用于取值，变量是一个 `RHS`（右手边）引用。

* `LHS` 和 `RHS` 引用查询都从当前执行中的作用域开始，它们会在嵌套的作用域中一路向上，一次一个作用域（层）地查找这个标识符，直到它们到达全局作用域（顶层）并停止，既可能找到也可能没找到。

* 未找到的 `RHS` 引用会导致 `ReferenceError` 被抛出。

* 未找到的 `LHS` 引用会导致一个自动的，隐含地创建的同名全局变量（如果不是“Strict模式”），或者一个 `ReferenceError`（“Strict模式”）。

### 词法作用域

js采用词法作用域，意味着作用域是由编写时函数被声明的位置决定。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并在执行期间预测它们将如何被查询。（例外是`eval()`,`with`，不推荐使用）

### 函数作用域和块作用域

在 `JavaScript` 中函数是最常见的作用域单位。在另一个函数内部声明的变量和函数，实质上对任何外围“作用域”都是“隐藏的”，这是优秀软件的一个有意的设计原则。

但是函数绝不是唯一的作用域单位。块儿作用域指的是这样一种想法：变量和函数可以属于任意代码块（一般来说，就是任意的 { .. }。

从 `ES3` 开始，`try`/`catch` 结构在 `catch` 子句上拥有块儿作用域。

在 `ES6` 中，引入了 `let` 关键字（`var` 关键字的表兄弟）允许在任意代码块中声明变量。`if (..) { let a = 2; }` 将会声明变量 `a`，而它实质上劫持了 `if` 的 `{ .. }` 块儿的作用域，并将自己附着在这里。