(window.webpackJsonp=window.webpackJsonp||[]).push([[337],{697:function(a,t,e){"use strict";e.r(t);var s=e(25),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[a._v("#")]),a._v(" 引用")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/codebase-overview.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("官网"),e("OutboundLink")],1)]),a._v(" "),e("h1",{attrs:{id:"源码概览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码概览"}},[a._v("#")]),a._v(" 源码概览")]),a._v(" "),e("h2",{attrs:{id:"项目根目录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#项目根目录"}},[a._v("#")]),a._v(" 项目根目录")]),a._v(" "),e("p",[a._v("当克隆 "),e("code",[a._v("React")]),a._v(" 仓库之后，将看到项目根目录的信息")]),a._v(" "),e("ul",[e("li",[e("p",[e("code",[a._v("packages")]),a._v(" 包含元数据（比如 "),e("code",[a._v("package.json")]),a._v("）和 React 仓库中所有 package 的源码（子目录 "),e("code",[a._v("src")]),a._v("）。"),e("strong",[a._v("如果需要修改源代码, 那么每个包的 src 子目录是最需要花费精力的地方")]),a._v("。")])]),a._v(" "),e("li",[e("p",[e("code",[a._v("fixtures")]),a._v(" 包含一些给贡献者准备的小型 React 测试项目。")])]),a._v(" "),e("li",[e("p",[e("code",[a._v("build")]),a._v(" 是 React 的输出目录。源码仓库中并没有这个目录，但是它会在克隆 React 并且第一次构建它之后出现。")])])]),a._v(" "),e("h2",{attrs:{id:"共置测试"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#共置测试"}},[a._v("#")]),a._v(" 共置测试")]),a._v(" "),e("p",[a._v("没有单元测试的顶层目录。而是将它们放置在所需测试文件的相同目录下的 "),e("code",[a._v("__tests__")]),a._v(" 的目录之中。")]),a._v(" "),e("p",[a._v("比如，一个用于 "),e("code",[a._v("setInnerHTML.js")]),a._v(" 的测试文件，会存放在 "),e("code",[a._v("__tests__/setInnerHTML-test.js")]),a._v("，就在它同级目录下。")]),a._v(" "),e("h2",{attrs:{id:"warning-和-invariant"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#warning-和-invariant"}},[a._v("#")]),a._v(" warning 和 invariant")]),a._v(" "),e("p",[a._v("React 代码库直接使用 "),e("code",[a._v("console.error")]),a._v(" 来展示 warnings：")]),a._v(" "),e("div",{staticClass:"language-jsx line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("__DEV__"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("error")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Something is wrong.'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("p",[a._v("warning 仅在开发环境中启用。在生产环境中，他们会被完全剔除掉。如果需要在生产环境禁止执行某些代码，请使用 "),e("code",[a._v("invariant")]),a._v(" 模块代替 "),e("code",[a._v("warning")]),a._v("：")]),a._v(" "),e("div",{staticClass:"language-jsx line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" invariant "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[a._v("'invariant'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("invariant")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("===")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v("'You shall not pass!'")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("p",[e("strong",[a._v("当 invariant 判别条件为 false 时，会将 invariant 的信息作为错误抛出")])]),a._v(" "),e("p",[a._v("“Invariant” 用于声明 “这个条件应总为 true”。可以把它当成一种断言。")]),a._v(" "),e("p",[a._v("保持开发和生产环境的行为相似是十分重要的，因此 "),e("code",[a._v("invariant")]),a._v(" 在开发和生产环境下都会抛出错误。不同点在于在生产环境中这些错误信息会被自动替换成错误代码，这样可以让输出库文件变得更小。")]),a._v(" "),e("h2",{attrs:{id:"开发环境与生产环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开发环境与生产环境"}},[a._v("#")]),a._v(" 开发环境与生产环境")]),a._v(" "),e("p",[a._v("可以在代码库中使用 "),e("code",[a._v("__DEV__")]),a._v(" 这个伪全局变量，用于管理开发环境中需运行的代码块")]),a._v(" "),e("p",[a._v("这在编译阶段会被内联，在 CommonJS 构建中，转化成 "),e("code",[a._v("process.env.NODE_ENV !== 'production'")]),a._v(" 这样的判断。")]),a._v(" "),e("p",[a._v("对于独立构建来说，在没有 minify 的构建中，它会变成 "),e("code",[a._v("true")]),a._v("，同时在 minify 的构建中，检测到的 "),e("code",[a._v("if")]),a._v(" 代码块会被完全剔除。")]),a._v(" "),e("div",{staticClass:"language-jsx line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("__DEV__"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 仅在开发环境下执行的代码")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("h2",{attrs:{id:"flow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flow"}},[a._v("#")]),a._v(" Flow")]),a._v(" "),e("p",[a._v("最近将 "),e("code",[a._v("Flow")]),a._v(" 引入源码，用于类型检查。在许可证头部的注释中，标记为 "),e("code",[a._v("@flow")]),a._v(" 注释的文件是已经经过类型检查的。")]),a._v(" "),e("p",[a._v("接受"),e("code",[a._v("添加 Flow 注释到现有代码")]),a._v("。Flow 注释看上去像这样：")]),a._v(" "),e("div",{staticClass:"language-jsx line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[a._v("ReactRef"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("detachRefs")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("instance"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" ReactInstance"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  element"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" ReactElement "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" string "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" number "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")])]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ...")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("p",[a._v("如果可以的话，新代码应尽量使用 Flow 注释。 可以运行 "),e("code",[a._v("yarn flow")]),a._v("，用 Flow 本地检查的代码。")]),a._v(" "),e("h2",{attrs:{id:"multiple-packages"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#multiple-packages"}},[a._v("#")]),a._v(" Multiple Packages")]),a._v(" "),e("p",[a._v("React 采用 "),e("a",{attrs:{href:"https://danluu.com/monorepo/",target:"_blank",rel:"noopener noreferrer"}},[a._v("monorepo"),e("OutboundLink")],1),a._v(" 的管理方式。仓库中包含多个独立的包，以便于更改可以一起联调，并且问题只会出现在同一地方。")]),a._v(" "),e("h2",{attrs:{id:"react-core"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-core"}},[a._v("#")]),a._v(" React Core")]),a._v(" "),e("p",[a._v("React “Core” 中包含所有"),e("code",[a._v("全局 React API")]),a._v("，比如：")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("React.createElement()")])]),a._v(" "),e("li",[e("p",[a._v("React.Component")])]),a._v(" "),e("li",[e("p",[a._v("React.Children")])])]),a._v(" "),e("p",[e("strong",[a._v("React 核心只包含定义组件必要的 API")]),a._v("。它不包含协调算法或者其他平台特定的代码。它同时适用于 React DOM 和 React Native 组件。")]),a._v(" "),e("p",[a._v("React 核心代码在源码的 "),e("code",[a._v("packages/react")]),a._v(" 目录中。在 npm 上发布为 "),e("code",[a._v("react")]),a._v(" 包。相应的独立浏览器构建版本称为 "),e("code",[a._v("react.js")]),a._v("，它会导出一个称为 "),e("code",[a._v("React")]),a._v(" 的全局对象。")]),a._v(" "),e("h2",{attrs:{id:"渲染器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染器"}},[a._v("#")]),a._v(" 渲染器")]),a._v(" "),e("p",[a._v("React 最初只是服务于 DOM，但是这之后被改编成也能同时支持原生平台的 React Native。因此，在 React 内部机制中引入了“渲染器”这个概念。")]),a._v(" "),e("p",[e("strong",[a._v("渲染器用于管理一棵 React 树，使其根据底层平台进行不同的调用")]),a._v("。")]),a._v(" "),e("p",[a._v("渲染器同样位于 "),e("code",[a._v("packages/")]),a._v(" 目录下：")]),a._v(" "),e("ul",[e("li",[e("p",[e("code",[a._v("React DOM Renderer")]),a._v(" 将 React 组件渲染成 DOM。它实现了全局 "),e("code",[a._v("ReactDOMAPI")]),a._v("，这在npm上作为 "),e("code",[a._v("react-dom")]),a._v(" 包。这也可以作为单独浏览器版本使用，称为 "),e("code",[a._v("react-dom.js")]),a._v("，导出一个 "),e("code",[a._v("ReactDOM")]),a._v(" 的全局对象.")])]),a._v(" "),e("li",[e("p",[e("code",[a._v("React Native Renderer")]),a._v(" 将 React 组件渲染为 Native 视图。此渲染器在 React Native 内部使用。")])]),a._v(" "),e("li",[e("p",[e("code",[a._v("React Test Renderer")]),a._v(" 将 React 组件渲染为 JSON 树。这用于 "),e("code",[a._v("Jest")]),a._v(" 的"),e("code",[a._v("快照测试")]),a._v("特性。在 npm 上作为 "),e("code",[a._v("react-test-renderer")]),a._v(" 包发布。")])])]),a._v(" "),e("p",[a._v("另外一个官方支持的渲染器的是 "),e("code",[a._v("react-art")]),a._v("。它曾经是一个独立的 "),e("code",[a._v("GitHub 仓库")]),a._v("，但是现在将此加入了主源代码树。")]),a._v(" "),e("blockquote",[e("p",[e("strong",[a._v("注意")]),a._v(":")]),a._v(" "),e("p",[a._v("严格说来，"),e("code",[a._v("react-native-renderer")]),a._v(" 实现了 React 和 React Native 的连接。真正渲染 Native 视图的平台特定代码及组件都存储在 "),e("code",[a._v("React Native 仓库")]),a._v("中。")])]),a._v(" "),e("h2",{attrs:{id:"reconcilers"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reconcilers"}},[a._v("#")]),a._v(" reconcilers")]),a._v(" "),e("p",[a._v("即便 React DOM 和 React Native 渲染器的区别很大，但也需要共享一些逻辑。特别是协调算法需要尽可能相似，这样可以让声明式渲染，自定义组件，state，生命周期方法和 refs 等特性，保持跨平台工作一致。")]),a._v(" "),e("p",[a._v("为了解决这个问题，不同的渲染器彼此共享一些代码。称 React 的这一部分为 “reconciler”。当处理类似于 "),e("code",[a._v("setState()")]),a._v(" 这样的更新时，reconciler 会调用树中组件上的 "),e("code",[a._v("render()")]),a._v("，然后决定是否进行挂载，更新或是卸载操作。")]),a._v(" "),e("p",[a._v("Reconciler 没有单独的包，因为他们暂时没有公共 API。相反，它们被如 React DOM 和 React Native 的渲染器排除在外。")]),a._v(" "),e("h2",{attrs:{id:"fiber-reconciler"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber-reconciler"}},[a._v("#")]),a._v(" Fiber reconciler")]),a._v(" "),e("p",[a._v("“fiber” reconciler 是一个新尝试，致力于解决 stack reconciler 中固有的问题，同时解决一些历史遗留问题。Fiber 从 React 16 开始变成了默认的 reconciler。")]),a._v(" "),e("p",[a._v("它的主要目标是：")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("能够把可中断的任务切片处理。")])]),a._v(" "),e("li",[e("p",[a._v("能够调整优先级，重置并复用任务。")])]),a._v(" "),e("li",[e("p",[a._v("能够在父元素与子元素之间交错处理，以支持 React 中的布局。")])]),a._v(" "),e("li",[e("p",[a._v("能够在 render() 中返回多个元素。")])]),a._v(" "),e("li",[e("p",[a._v("更好地支持错误边界。")])])]),a._v(" "),e("p",[a._v("源代码在 "),e("code",[a._v("packages/react-reconciler")]),a._v(" 目录下")]),a._v(" "),e("h2",{attrs:{id:"事件系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件系统"}},[a._v("#")]),a._v(" 事件系统")]),a._v(" "),e("p",[a._v("React 在原生事件基础上进行了封装，以抹平浏览器间差异。其源码在 "),e("code",[a._v("packages/react-dom/src/events")]),a._v(" 目录下")])])}),[],!1,null,null,null);t.default=r.exports}}]);