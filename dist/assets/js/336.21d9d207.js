(window.webpackJsonp=window.webpackJsonp||[]).push([[336],{696:function(v,_,e){"use strict";e.r(_);var o=e(25),c=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("这个问题感觉可能描述的不全面，先讲一下的描述吧：")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("单向数据流。React是一个MVVM框架，简单来说是在MVC的模式下在前端部分拆分出数据层和视图层。单向数据流指的是只能由数据层的变化去影响视图层的变化，而不能反过来（除非双向绑定）")])]),v._v(" "),e("li",[e("p",[v._v("数据驱动视图。无需关注页面的DOM，只需要关注数据即可")])]),v._v(" "),e("li",[e("p",[v._v("渲染过程，生命周期……")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("setState()")]),v._v("大部分时候是异步执行的，提升性能。")])])]),v._v(" "),e("p",[v._v("从一个完整的流程来说：首先编写的jsx会被转换执行返回"),e("code",[v._v("node")]),v._v("对象，"),e("code",[v._v("node")]),v._v("对象就可以理解为是虚拟"),e("code",[v._v("dom")]),v._v("，渲染时都会将老的虚拟"),e("code",[v._v("dom")]),v._v("和新的虚拟"),e("code",[v._v("dom")]),v._v("来进行比对，比对的过程中就涉及到了"),e("code",[v._v("diff")]),v._v("算法，只比较同一层的节点，节点"),e("code",[v._v("tag")]),v._v("不同，就不再比较，以新的节点为准，节点相同就比较"),e("code",[v._v("key")]),v._v("，"),e("code",[v._v("key")]),v._v("不同也会以新节点为准；之后就将最终的虚拟"),e("code",[v._v("dom")]),v._v("，再渲染在浏览器中；"),e("code",[v._v("props")]),v._v("，"),e("code",[v._v("state")]),v._v("的更新也会触发这一流程")]),v._v(" "),e("p",[e("code",[v._v("React")]),v._v("整个渲染机制就是"),e("code",[v._v("React")]),v._v("会调用"),e("code",[v._v("React.render()")]),v._v("构建一颗"),e("code",[v._v("DOM")]),v._v("树\n当"),e("code",[v._v("state")]),v._v("或"),e("code",[v._v("props")]),v._v("改变时,"),e("code",[v._v("render()")]),v._v("会被再次调用构建出另外一颗树,利用"),e("code",[v._v("Diff")]),v._v("算法与之前的树进行对比,找到需要更新的地方进行更新并渲染到页面上,实现按需更新减少对真实"),e("code",[v._v("DOM")]),v._v("的操作,实现性能优化\n个人理解这个问题重点在"),e("code",[v._v("React.render()")]),v._v(" 和 "),e("code",[v._v("Diff")]),v._v("算法上")])])}),[],!1,null,null,null);_.default=c.exports}}]);