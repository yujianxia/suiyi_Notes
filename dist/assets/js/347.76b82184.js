(window.webpackJsonp=window.webpackJsonp||[]).push([[347],{707:function(e,t,r){"use strict";r.r(t);var n=r(25),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("首先，什么是渲染劫持：渲染劫持的概念是控制组件从另一个组件输出的能力，当然这个概念一般和react中的高阶组件（HOC）放在一起解释比较有明了。")]),e._v(" "),r("p",[e._v("高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出，只要改变了原组件的渲染，都将它称之为一种"),r("code",[e._v("渲染劫持")]),e._v("。")]),e._v(" "),r("p",[e._v("实际上，在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可以增强由原组件render函数产生的React元素。")]),e._v(" "),r("p",[e._v("实际的操作中 通过 操作 state、props 都可以实现渲染劫持")]),e._v(" "),r("p",[e._v("的理解：\n什么是渲染劫持？来分析一下这个词汇。渲染主要指的是组件中的render函数return的JSX语法部分。劫持呢？如果在组件内部去修改JSX语法，这不叫劫持，这是分内的事情。劫持指的是在本不应该修改到JSX语法的地方修改了它。怎么实现呢？一般都是通过继承被劫持的组件。\nHOC（高阶组件）有一种反向继承的用法。当然，不止HOC，也可以新写一个组件，继承一个已有的组件，在这里就可以随意修改render函数，使用state、props这些状态数据，改变了原组件的渲染，这就叫渲染劫持。")])])}),[],!1,null,null,null);t.default=s.exports}}]);